{
  "description": "Java 8",
  "questions": {
    "1": "What are the main features introduced in Java 8?",
    "2": "What is a lambda expression in Java 8?",
    "3": "How do you define and use lambda expressions in Java 8?",
    "4": "What is the difference between a lambda expression and an anonymous class?",
    "5": "What are the benefits of using lambda expressions?",
    "6": "What is a functional interface in Java 8?",
    "7": "What is the @FunctionalInterface annotation in Java 8?",
    "8": "Can you define multiple abstract methods in a functional interface?",
    "9": "What are method references in Java 8?",
    "10": "What are the types of method references in Java 8?",
    "11": "How do you use constructor references in Java 8?",
    "12": "What is the Stream API in Java 8?",
    "13": "What is the difference between Stream and Collection?",
    "14": "What are intermediate and terminal operations in Stream API?",
    "15": "How do you create a stream from a collection in Java 8?",
    "16": "How do filter() and map() work in streams?",
    "17": "What is flatMap() in the Stream API? How does it differ from map()?",
    "18": "What is reduce() in Java 8 streams, and when do you use it?",
    "19": "What is the purpose of collect() in Java 8 streams?",
    "20": "What is Collectors.toList() in Java 8?",
    "21": "How do you create a stream of Map values in Java 8?",
    "22": "How do you sort elements in a stream in Java 8?",
    "23": "What is the difference between findFirst() and findAny() in Java 8?",
    "24": "What is Optional in Java 8?",
    "25": "How do you create an Optional object in Java 8?",
    "26": "What are the methods provided by the Optional class in Java 8?",
    "27": "How do you handle null values with Optional in Java 8?",
    "28": "What is Optional.ifPresent() in Java 8?",
    "29": "What is Optional.orElse() in Java 8?",
    "30": "How does Optional.map() and flatMap() work in Java 8?",
    "31": "How do you combine streams and Optional in Java 8?",
    "32": "What is the forEach() method in Java 8? How is it used?",
    "33": "How do default methods work in interfaces in Java 8?",
    "34": "Can you override default methods in Java 8?",
    "35": "What is the purpose of static methods in interfaces in Java 8?",
    "36": "How do you use Predicate in Java 8?",
    "37": "What is the Function interface in Java 8?",
    "38": "What is the Consumer interface in Java 8?",
    "39": "What is the Supplier interface in Java 8?",
    "40": "What is the BiFunction interface in Java 8?",
    "41": "What is the difference between Function and BiFunction in Java 8?",
    "42": "What is the UnaryOperator interface in Java 8?",
    "43": "What is the BinaryOperator interface in Java 8?",
    "44": "How do you use the Comparator interface with lambda expressions in Java 8?",
    "45": "What is Comparator.thenComparing() in Java 8?",
    "46": "What is the purpose of Collectors.joining() in Java 8?",
    "47": "What is the partitioningBy() method in Collectors in Java 8?",
    "48": "How do you use groupingBy() with collectors in Java 8?",
    "49": "What is parallelStream() in Java 8? How does it differ from stream()?",
    "50": "How does parallel processing work with Stream API in Java 8?",
    "51": "What is the CompletableFuture in Java 8?",
    "52": "How do you use CompletableFuture.runAsync() in Java 8?",
    "53": "What is CompletableFuture.supplyAsync() in Java 8?",
    "54": "How do you handle asynchronous tasks with CompletableFuture in Java 8?",
    "55": "How do you combine two CompletableFuture instances in Java 8?",
    "56": "What is the thenApply() method in CompletableFuture?",
    "57": "What is the thenAccept() method in CompletableFuture?",
    "58": "What are the new Date and Time APIs in Java 8?",
    "59": "What is the LocalDate class in Java 8?",
    "60": "What is the LocalTime class in Java 8?",
    "61": "What is the LocalDateTime class in Java 8?",
    "62": "How does the Period class work in Java 8?",
    "63": "What is the Duration class in Java 8?",
    "64": "How does the Instant class work in Java 8?",
    "65": "What is the DateTimeFormatter in Java 8?",
    "66": "How do you format and parse dates in Java 8?",
    "67": "What are the enhancements to java.util.concurrent in Java 8?",
    "68": "How do you use ForkJoinPool in Java 8?",
    "69": "What are StampedLock and ReadWriteLock in Java 8?",
    "70": "How do CompletableFuture and Future differ in Java 8?",
    "71": "What is the purpose of the Files.lines() method in Java 8?",
    "72": "How do you filter and process large files using Stream API in Java 8?",
    "73": "What is the Collectors.toMap() method in Java 8?",
    "74": "How do you convert a list to a map using Stream in Java 8?",
    "75": "How do method references differ from lambda expressions in Java 8?"
  },
  "groups": {
    "1": "Java 8 Features",
    "2": "Lambda Expressions",
    "3": "Lambda Expressions",
    "4": "Lambda Expressions",
    "5": "Lambda Expressions",
    "6": "Functional Interfaces",
    "7": "Functional Interfaces",
    "8": "Functional Interfaces",
    "9": "Method References",
    "10": "Method References",
    "11": "Method References",
    "12": "Stream API",
    "13": "Stream API",
    "14": "Stream API",
    "15": "Stream API",
    "16": "Stream API",
    "17": "Stream API",
    "18": "Stream API",
    "19": "Stream API",
    "20": "Stream API",
    "21": "Stream API",
    "22": "Stream API",
    "23": "Stream API",
    "24": "Optional",
    "25": "Optional",
    "26": "Optional",
    "27": "Optional",
    "28": "Optional",
    "29": "Optional",
    "30": "Optional",
    "31": "Optional",
    "32": "Stream API",
    "33": "Default Methods",
    "34": "Default Methods",
    "35": "Default Methods",
    "36": "Functional Interfaces",
    "37": "Functional Interfaces",
    "38": "Functional Interfaces",
    "39": "Functional Interfaces",
    "40": "Functional Interfaces",
    "41": "Functional Interfaces",
    "42": "Functional Interfaces",
    "43": "Functional Interfaces",
    "44": "Functional Interfaces",
    "45": "Functional Interfaces",
    "46": "Stream API",
    "47": "Stream API",
    "48": "Stream API",
    "49": "Stream API",
    "50": "Stream API",
    "51": "CompletableFuture",
    "52": "CompletableFuture",
    "53": "CompletableFuture",
    "54": "CompletableFuture",
    "55": "CompletableFuture",
    "56": "CompletableFuture",
    "57": "CompletableFuture",
    "58": "Date and Time API",
    "59": "Date and Time API",
    "60": "Date and Time API",
    "61": "Date and Time API",
    "62": "Date and Time API",
    "63": "Date and Time API",
    "64": "Date and Time API",
    "65": "Date and Time API",
    "66": "Date and Time API",
    "67": "Concurrency Enhancements",
    "68": "Concurrency Enhancements",
    "69": "Concurrency Enhancements",
    "70": "Concurrency Enhancements",
    "71": "File I/O",
    "72": "File I/O",
    "73": "Stream API",
    "74": "Stream API",
    "75": "Lambda Expressions"
  },
  "answers": {
    "1": "Java 8 introduced major features like lambda expressions, the Stream API, Optional, functional interfaces, default and static methods in interfaces, method references, and the new Date and Time API.",
    "2": "A lambda expression is a concise way to represent an anonymous function that can be passed around, offering functional programming capabilities in Java.",
    "3": "You define a lambda expression using the syntax: (parameters) -> expression or (parameters) -> { statements }. It is used to define the method inline and passed as a parameter.",
    "4": "A lambda expression provides a concise syntax, whereas an anonymous class requires more verbose code. Lambda can only be used with functional interfaces.",
    "5": "Benefits include more readable and concise code, enabling functional programming, easier parallel processing with the Stream API, and less boilerplate code.",
    "6": "A functional interface is an interface that contains only one abstract method. It can be implemented by a lambda expression or method reference.",
    "7": "The @FunctionalInterface annotation is used to indicate that an interface is intended to be a functional interface, which means it should only have one abstract method.",
    "8": "No, a functional interface can have only one abstract method, though it can have multiple default and static methods.",
    "9": "A method reference is a shorthand notation of a lambda expression that refers to a method directly by name.",
    "10": "There are four types of method references: static method reference, instance method reference, constructor reference, and super method reference.",
    "11": "You use constructor references with the syntax ClassName::new to refer to a constructor in lambda expressions.",
    "12": "The Stream API allows for functional-style operations on streams of elements, supporting sequential and parallel processing of data.",
    "13": "A collection is a data structure to store elements, while streams are used to process data from collections and arrays using functional operations.",
    "14": "Intermediate operations transform a stream and are lazy (e.g., filter, map), while terminal operations consume the stream (e.g., collect, forEach).",
    "15": "You can create a stream from a collection using the collection's stream() or parallelStream() method.",
    "16": "filter() removes elements based on a condition, while map() transforms elements by applying a function.",
    "17": "flatMap() flattens a stream of collections into a single stream, while map() applies a function to each element.",
    "18": "reduce() combines all elements of a stream into a single result using a specified binary operator.",
    "19": "collect() transforms a stream into another data structure like a List, Set, or Map.",
    "20": "Collectors.toList() collects the elements of a stream into a List.",
    "21": "You can create a stream from the values of a Map by using map.values().stream().",
    "22": "You can sort elements using stream.sorted(), which takes a comparator to define the order.",
    "23": "findFirst() returns the first element of the stream, while findAny() returns any element, which is useful in parallel streams.",
    "24": "Optional is a container object introduced to handle null values and avoid NullPointerException.",
    "25": "You can create an Optional using Optional.of(), Optional.ofNullable(), or Optional.empty().",
    "26": "Optional provides methods like isPresent(), ifPresent(), orElse(), orElseGet(), and get() to handle optional values.",
    "27": "You can use Optional to avoid null checks and handle absent values more gracefully using methods like orElse() and ifPresent().",
    "28": "Optional.ifPresent() executes a block of code if a value is present.",
    "29": "Optional.orElse() provides a fallback value if the Optional is empty.",
    "30": "Optional.map() transforms the value inside the Optional, while flatMap() returns another Optional.",
    "31": "You can combine Optional with streams by transforming Optional values into streams or combining the two for more complex processing.",
    "32": "forEach() allows performing an action for each element of the stream. It is a terminal operation.",
    "33": "Default methods in interfaces provide a body, allowing you to add new functionality to interfaces without breaking existing implementations.",
    "34": "Yes, default methods can be overridden in implementing classes.",
    "35": "Static methods in interfaces are utility methods related to the interface and are not inherited by implementing classes.",
    "36": "Predicate is a functional interface that represents a condition or boolean-valued function, often used in filter() operations.",
    "37": "Function is a functional interface that represents a function that takes an argument and returns a result.",
    "38": "Consumer is a functional interface that represents an operation that takes an argument but returns no result.",
    "39": "Supplier is a functional interface that represents a supplier of results and takes no arguments.",
    "40": "BiFunction is a functional interface that takes two arguments and returns a result.",
    "41": "Function takes a single argument, while BiFunction takes two arguments.",
    "42": "UnaryOperator is a specialization of Function that takes a single argument and returns a result of the same type.",
    "43": "BinaryOperator is a specialization of BiFunction that takes two arguments of the same type and returns a result of the same type.",
    "44": "You can use the Comparator interface with lambda expressions to define custom sorting logic.",
    "45": "Comparator.thenComparing() is used to chain multiple comparison criteria when sorting.",
    "46": "Collectors.joining() concatenates stream elements into a single String.",
    "47": "partitioningBy() divides elements into two groups based on a predicate.",
    "48": "groupingBy() groups elements of a stream by a classifier and returns a Map.",
    "49": "parallelStream() enables parallel processing, breaking the data into multiple threads for concurrent execution.",
    "50": "Parallel processing splits the task into smaller parts and processes them concurrently, improving performance for large data sets.",
    "51": "CompletableFuture is a class in Java 8 that allows asynchronous programming and combining future results.",
    "52": "CompletableFuture.runAsync() runs a task asynchronously and returns a CompletableFuture<Void>.",
    "53": "CompletableFuture.supplyAsync() runs a task asynchronously and returns a CompletableFuture with the result.",
    "54": "You can handle asynchronous tasks by combining multiple CompletableFuture instances and chaining them using methods like thenApply() and thenAccept().",
    "55": "You can combine two CompletableFuture instances using methods like thenCombine(), thenCompose(), or allOf().",
    "56": "thenApply() is used to transform the result of a CompletableFuture.",
    "57": "thenAccept() is used to consume the result of a CompletableFuture without returning any value.",
    "58": "Java 8 introduced a new Date and Time API in the java.time package to address the issues with java.util.Date and java.util.Calendar.",
    "59": "LocalDate represents a date without time or timezone.",
    "60": "LocalTime represents a time without date or timezone.",
    "61": "LocalDateTime represents a date and time without timezone.",
    "62": "The Period class represents the amount of time between two LocalDate instances.",
    "63": "The Duration class represents the amount of time between two instances, typically LocalTime or LocalDateTime.",
    "64": "The Instant class represents a specific moment on the timeline, measured in milliseconds from the epoch.",
    "65": "DateTimeFormatter is used to format and parse date and time objects in the new Date and Time API.",
    "66": "You can format dates using DateTimeFormatter and parse them using LocalDate or LocalDateTime classes.",
    "67": "Enhancements to java.util.concurrent include CompletableFuture, improvements to ForkJoinPool, and new locks like StampedLock and ReadWriteLock.",
    "68": "ForkJoinPool is a framework used for parallel task execution by breaking tasks into smaller pieces and joining them.",
    "69": "StampedLock and ReadWriteLock provide lock mechanisms for concurrent programming, allowing multiple readers or a single writer.",
    "70": "CompletableFuture allows chaining and combining tasks asynchronously, while Future only represents the result of an asynchronous computation.",
    "71": "Files.lines() reads all lines from a file as a Stream, enabling you to process large files more efficiently.",
    "72": "You can filter and process large files using Files.lines() to read lines as a Stream and applying stream operations like filter() and map().",
    "73": "Collectors.toMap() is used to collect elements of a stream into a Map.",
    "74": "You can convert a list to a map using stream() and Collectors.toMap() to provide the key-value mapping.",
    "75": "Method references provide a more concise syntax compared to lambda expressions, allowing you to refer to methods directly by name."
  }
}
